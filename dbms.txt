DBMS

**********************************RAID (Theory)*******************************************************
RAID=Redundant Arrays of Independent Disk

Disk Organization Technique. It combines multiple hard drive or SSD into a single system to improve performance, data safety or both. If one drive fails, data can still be recovered from the drive. (This is called fault tolerance)

Types: 1. Hardware RAID (Faster, most used)
       2. Software RAID (Slower, less used)

RAID=> 0,1(Mirroring),2,3,4,5,6, Nested

=========>2NF: (Study from Slide)

*****************************************Decomposition (Theory)***************************************

    Condition 1: Union of both sub relation must contain all attribute that are present in the original relation R. 
    ==> R1 U R2=R
    ==>R(A,B,C)=> Sub relation R1(A,B) and R2(B,C)
    ==>Now, R1 U R2= (A,B) U (B,C)= (A,B,C)= R
    
    Condition 2: Intersection of the sub relations must not be NULL
    ==>R1 intersect R2= Not NULL
    
    Condition 3: Intersect of the sub relations must be a super key of either R1 or R2.




**********************************Candidate Key (Theory)******************************************
 =======>> See Hand note

*****************************Mandatory Set (Normalization, Decomposition Theory) ************************

Normalization is a database design technique that reduces 
    > 1. Data redundency(Duplicate data)
    > 2. Ensure Data Integrity (Concept of Keys should be clear, Cascading should be perfect)

=> It divides larger tables into smaller tables and links them using relationship.
=> It eliminates undesirable characteristics like Insertion, Update and deletion Anomalies.


    Types of normalization:
        1NF, 2NF, 3NF(Update Ver of it is 3.5/BCNF=Boyce Codd Normal Form),4NF,5NF,6NF

    1NF (First Normal Form):
        Rules:
            -> Each column should contain atomic value/ does not conatin multi-value in a column
            -> Do not inter Mix different type of values in a column
            -> Each column should have unique name
    If no solution is found then decompose. (Split the table into multiple table)

Decompose: 
        -> Database table split
        -> It is done to ensure consistency, remove anomalies and duplicate data
        -> No information is lost (Even if extra data come, that's bad)

  Types: 
        1. Loss-less Decomposition
        2. Lossy Decomposition

R1 (natural join) R2 (natural join) R3 ......Rn=R 

(See hand Note)

HW: Super Key and Candidate Key Reading


***********************************************Cascading (Theory)*****************************************
Q: What is Cascade in SQL?
Answer: In SQL, the term cascade refers to "action triggered" automatically when a change occurs in a parent table.

There are 3 types of cascading operations in SQL:

1. Case Code  on Delete (When you delete from parent table, it will be deleted on child also)
2. Case Code  on Update (")
3. Case Code  on Insert (")

What are the importance of cascading in SQL?

Answer: a) One crucial feature of cascading in SQL is maintaining data integrity in database.

        b) Reduce the complexity of manual database management tasks.
        
*******************************************Cascading (Lab)************************************************
create database NovaDB
use NovaDB;

--Parent table
create table Authors ( AuthorID int primary key NOT NULL, AuthorName varchar(35));

insert into Authors Values (1, 'John Doe');
insert into Authors Values (2, 'Minal');
insert into Authors Values (3, 'Mahi');
insert into Authors Values (7, 'Somores');



--Child Table
create table  Books( BookID int primary key not null,
Title Varchar(35),
AuthorID int,
foreign key (AuthorID) references Authors(AuthorID) on delete cascade,
foreign key (AuthorID) references Authors(AuthorID) on update cascade
);

insert into Books values (105,'E-Business',7)



select * from Books;
select * from Authors;

--delete cascade
Delete from Authors 
where AuthorID =2;

--update cascade
update Authors
set AuthorID=5
where AuthorID=3;


--insert cascade
insert into Authors Values (7, 'Somores');
insert into Books values (105,'E-Business',7)

--There is no query for insert cascading , u can just insert into parent table and then same data can be entered into insert.
--MaÃ¡m suggests to say cascading is two types.


           




*************Assessment ( View & Index)******************************
create Database assessment201;
use assessment201;

create table tblEMP(EmpID int, EmpName varchar(35), EmpSalary int, EmpJoinDate DateTime);

insert into tblEMP values (2345 ,'Rasel',25000 ,'2018-01-01');
insert into tblEMP values (2452 ,'Nishan',15000 ,'2018-05-15');
insert into tblEMP values (2666 ,'Munira',32000 ,'2019-01-15');
insert into tblEMP values (2788 ,'Sadia',45000 ,'2019-02-20');

select * from tblEMP;


create table students (ID varchar(35), District varchar(35), Dept Varchar(35));

insert into students values ( '02345', 'Dhaka', 'IT');
insert into students values ( '02666', 'Rajshahi', 'IT');
insert into students values ('03562' , 'Rajshahi', 'HR');
insert into students values ( '02587', 'Khulna', 'PO');


select * from students;

create table Industry (Names varchar(45), Industry_Code int , Employees int, Annual_Income int);

insert into Industry values ('ACI', 1234, 200, 150);
insert into Industry values ('SK-F', 3245, 150, 2563);
insert into Industry values ('RFL', 1489, 117, 4857);
insert into Industry values ('GMG AirLine', 2541, 253, 3350);

select * from tblEMP;
select * from students;
select * from Industry;

select CAST(ID as int) as IDs from students;

--Q.1 View named EmpDetails to see EmpName and salary range 15000-20000 and employee names containing letter a.

create view EmpDetails
as select EmpName, EmpSalary from tblEMP
where EmpName LIKE '%a%' and
EmpSalary between 15000 and 20000
;

select * from EmpDetails;

--Q.2 View named EmpDetails2 to show EmpId, EmpSalary and Dept. Also update the dept of IT to Accounts that Employee whose name is Rasel

create view EmpDetails2 as
select EmpId, EmpSalary, Dept 
from tblEMP join students on tblEmp.EmpID=cast(students.ID as int);

select * from EmpDetails2;


create view EmpDetails3 as
select EmpId, EmpSalary, Dept 
from tblEMP join students on tblEmp.EmpID=cast(students.ID as int)
update students
set students.Dept = 'Accounts'
from students 
JOIN tblEMP 
  on tblEMP.EmpID = cast(students.ID AS INT)
where tblEMP.EmpName = 'Rasel'
  AND students.Dept = 'IT';

select * from EmpDetails3;

--Q.3 Define Industry code as primary key. Show the name of the Industry.

create table Industry (Names varchar(45), Industry_Code int primary key NOT NULL , Employees int, Annual_Income int);

insert into Industry values ('ACI', 1234, 200, 150);
insert into Industry values ('SK-F', 3245, 150, 2563);
insert into Industry values ('RFL', 1489, 117, 4857);
insert into Industry values ('GMG AirLine', 2541, 253, 3350);

select Names from Industry;

--Q.4 Clustered index on the industry table using Industry_code column. show output. And also create non-clustered index using annual_income column and show output.

create clustered index CI_industryIndex on Industry(Industry_Code) 

exec sp_helpindex 'Industry';

create nonclustered index NCI_industryIndex on Industry(Annual_Income)

exec sp_helpindex 'Industry';















******************************Type Casting, Date Convert, add, diff etc. Theory***************************
Type casting has two types:
                        1. Cast
                        2. Convert
>>Difference
        1. Different Syntax
        2. Cast cannot style Dates, convert can.

>>Mathematical functions:
    1.Absolute value 
        select abs (-5)
    2. Ceiling values
        select
    3. Floor
    4. Power
    5. Square

>> Day Month year fetching
        select DAY ('2025-10-28')
        select Month ('2025-10-28')
        select Year ('2025-10-28')


>>To show the systems date and Time
        1.select SYSDATETIME () as Time
        2.select GETDATE () 

>>To check date validation (Is it a date or not)
          1.select ISDATE ('2025-10-28') as Date
        
        ##Gives output as Binary 1(Correct),0(Incorrect)

>> To show the Day of a date
        select DATENAME (Day, '2025-10-28') --28
        select DATENAME (MONTH, '2025-10-28') --October
        select DATENAME (YEAR, '2025-10-28') --2025
        select DATENAME (WEEKDAY, '2025-10-28') --Tuesday



--*Lab of Type Cast, Date covert****************

--Type Cast
select CAST (33.55 as int) as output
select CAST (33 as float) as output
select CAST ('28-10-2025' as varchar) as output

--Convert 
select CONVERT (int,33.55) as output

--Date styling in DBMS
create table Employee (EmpName varchar (45), Dept varchar (45), JoiningDate varchar (45));

insert into Employee values ('Sara','Accounts','2017-05-03')
insert into Employee values ('Wahid','HR','2018-03-25')
insert into Employee values ('Michel','IT','2019-03-22')
insert into Employee values ('Jack','HR','2018-04-14')

--Not Working
Select EmpName , convert (nvarchar(45), JoiningDate, 0) as Date from Employee
--Instead get the date from System
Select EmpName , convert (nvarchar(45), GETDATE (), 9) as Date from Employee

--Show specific DAY MONTH YEAR
select DAY ('2025-10-28')
select Month ('2025-10-28')
select Year ('2025-10-28')

--To show system date time
select SYSDATETIME () as Time
select GETDATE ()

--To check the validity
select ISDATE ('2025-10-28') as Date

--To show the Day of a date
select DATENAME (Day, '2025-10-28') --28
select DATENAME (MONTH, '2025-10-28') --October
select DATENAME (YEAR, '2025-10-28') --2025
select DATENAME (WEEKDAY, '2025-10-28') --Tuesday

--For Date add
select Dateadd(DAY, 5, '2019/3/22')
select Dateadd(MONTH, 5, '2019/3/22')
select Dateadd(YEAR, 5, '2019/3/22')


--For Date Difference
select DateDiff(Day,'2018/3/22','2019/3/22') 
select DateDiff(MONTH,'2018/3/22','2019/3/22') 
select DateDiff(YEAR,'2018/3/22','2019/3/22') 
--(Day, 'Starting date/Smaller value', 'Ending Date/Bigger Date') Otherwise it wil give negative value





********************************View*********************************************
                 
                 **************Theory***************

## It is called the virtual table/relation of database
## stored procedure, index, table are the object of database
## This hold or exist permanently the data of these objects
## These hold permanent memory location of database
## View does not use the memory location of database; it's called temporary object.

## Stored procedure has the feature of encryption.
## Index has feature of fast performance, organised data, efficient.
#### Index two types 1. Clustered Index (Memory Efficient, Single)  
                     2. Non-Clustered Index

##*Why study View??
           To hide certain data from the view of certain user 
##*Drawback of View
           1. Here when we change the department name of Jhon from HR to IT,
             it changes all the HR department to the IT.
           2. It's the drawback of View.
##*HW
        Index (Materialized) View VS. Normal View??
    
         1. Index View= We have to write (with schemabinding)
         2. Table name must be (dbo.tableName)

#***   Index View is used in Data Ware Houses

   *************************Lab of View*******************************
                    

--Table creation
create table student_sessions (ID int, Name varchar (35), CGPA float, Session varchar (35));
insert into student_sessions values (1, 'Jackson', 3.7, 'Fall 17')
insert into student_sessions values (2, 'Ronald', 3.86, 'Spring 19')
insert into student_sessions values (3, 'Jemmy', 3.55, 'Summer 20')
insert into student_sessions values (4, 'Smith', 3.4, 'Spring 21')

--Delete table
drop table student_sessions;

--syntax of view
create view Stud_Session
as select Name, Session from student_sessions;


--change the query of view
alter view Stud_Session
as select Name, Session 
from student_sessions
where Session='Spring 19';


--To show the value of view
select * from  Stud_Session;

--Update 
update Stud_Session
set CGPA=3.75
where Name='Jackson';


--Multiple Table working
create table tblEmployee (ID int, Name varchar (35), Gender varchar (45), DepartmentID int);
insert into  tblEmployee values (1, 'Jhon', 'Male', 3);
insert into  tblEmployee values (2, 'Mickey', 'Male', 2);
insert into  tblEmployee values (3, 'Ronald', 'Male', 1);
insert into  tblEmployee values (4,'Sara', 'Female', 4);
insert into  tblEmployee values (5, 'Michel', 'Male', 1);
insert into  tblEmployee values (6, 'Smith', 'Male', 3);

create table tblDepartment (Deptid int, Department varchar (56));
 
insert into tblDepartment values (1, 'IT');
insert into tblDepartment values (2, 'Payroll');
insert into tblDepartment values (3, 'HR');
insert into tblDepartment values (4, 'Admin');

select * from tblDepartment;
select * from tblEmployee;

--create view by joining two tables
create view student_Info
as select ID,Name,DepartmentID,Department
from tblEmployee join tblDepartment
on tblEmployee.DepartmentID=tblDepartment.Deptid;

--Show the output
select * from student_Info;

--Update the joined two tables view
update student_Info
set Department='IT'
where Name= 'Jhon'








************************Index*************************************************************
create database index_lab_1_204
use index_lab_1_204

create table Admission (Id int, names varchar (50), CGPA float, sess varchar (50))

insert into Admission values (1, 'Jackson', 3.48, 'Spring-2020')
insert into Admission values (2, 'Smith', 3.56, 'Spring-2025')
insert into Admission values (3, 'Sara', 3.99, 'Summer-2020')
insert into Admission values (4, 'Ronald', 3.05, 'Spring-2025')
insert into Admission values (5, 'Jenelia', 3.88, 'Fall-2025')

select * from Admission


select * from Admission where CGPA between 3.5 and 4.00b -- here, the database pointer scans every cell of the table and then applies condition to find the wanted dtata. but this is too time consuming. 


		-- Clusterted Index (*By Default* by declaring Primary Key; one table-one clusted index)

create table default_empInfoDetails(EmpID int primary key not null, EmpNames varchar (50), Salary int, gender varchar (15))

insert into default_empInfoDetails values (1, 'Sara', 15000, 'F')
insert into default_empInfoDetails values (7, 'Smith', 25000, 'M')
insert into default_empInfoDetails values (3, 'Jara', 44000, 'F')

--drop table default_empInfoDetails

select * from default_empInfoDetails



				-- Clustered Index (manual creation)
create table empInfoDetails(EmpID int, EmpNames varchar (50), Salary int, gender varchar (15))

insert into empInfoDetails values (1, 'Sara', 15000, 'F')
insert into empInfoDetails values (7, 'Smith', 25000, 'M')
insert into empInfoDetails values (3, 'Jara', 44000, 'F')


--drop table empInfoDetails
select * from empInfoDetails

			--Clustered Index (manual SYNTAX)
create clustered index CI_EmpID_Detailes on empInfoDetails(EmpID) -- orders the table based on mentioned column

-- drop Syntax: drop index CI_EmpInfoDetailes on empInfoDetails

				                                             -- name of clustered and non-clustered indecies must be different--

			----Non-Clustered Index (manual creation)
create nonclustered index NCI_EmpName_Detailes on empInfoDetails(EmpNames)-- is same as select clause; doesn't work like clustered (doesn't order)
--drop index NCI_EmpInfoDetailes on empInfoDetails




select EmpNames from empInfoDetails where salary between 20000 and 50000





****************************************** Stored procedure Lec 1 Final***************************

Topic: Stored procedure
Defn: Stored procudure is a subroutine.
Subroutine: Line of code or collection of statement.
#include<iostream>
using namespace std;
int main (){
};

##Condition of Stored procedure
1. Stored procudure is a subroutine (some line of code.)
2. It's precompiled.
     2.1 write ''alter'' instead of ''create'' (No need to create again)
        	a. alter proc EmpDetails
     2.2 Edit the body part only 
3. It can be used again and again.

 --syntax of stored procedure 
 create proc EmpDetails
(Parameter)
 as begin
 --(Body part    (Write SQL query in between begin and end, Body part will consist of single SQL Query)
 select * from tblEmp
 --Body part) 
 end
 --execution query
 exec EmpDetails

##Delete permanently
 --drop proc
 drop proc EmplDetails
(Best to delete from design mode.)  
Path: Databases> current DB> Programmability> Stored Procedure> dbo.procedurename



##Parameter (To pass the value)

Identify: 1. Write before ''as'' clause
	     2. Starts with @

---------------------------------------------------------------------------------------------------------------------
create database final_1st_class;
use final_1st_class; 

create table tblEmp (Id int , Name varchar(34), Designation varchar(66),Salary int);

insert into tblEmp values (1, 'Robert', 'CEO',25000);
insert into tblEmp values (2, 'Michel', 'Manager',33000);
insert into tblEmp values (3, 'John', 'PO',40000);
insert into tblEmp values (4, 'Sara', 'Manager',15000);

select * from tblEmp;
 
 --syntax of stored procedure 
 create proc EmpDetails
 as begin
 --(Body part
 select * from tblEmp
 --Body part)
 end
 --execution query
 exec EmpDetails



 create table Employees (Emp_Id int , Emp_city varchar(34),Emp_name varchar(66));
 insert into Employees values (1, 'New York', 'Jack');
 insert into Employees values (2, 'Charlotte', 'Jill');

  --syntax of stored procedure 
 create proc EmployeesDetails
 as begin
 --(Body part
 select Emp_city, Emp_name from Employees;
 --Body part)
 end
 --execution query
 exec EmployeesDetails

--parameter
 select * from tblEmp;

  --syntax of stored procedure 
 create proc EmplDetails
 @Name varchar (34),           ---(Parameter name and Column name can be different)
 @Designation varchar(66)
 as begin
 --(Body part
 select Name, Designation from tblEmp
 where Name=@Name and 
 Designation=@Designation
 --Body part)
 end
 --execution query
 exec EmplDetails 'Sara', 'Manager' --(Single value pass only)
 exec EmplDetails 'Michel', 'Manager'
 --drop proc
 drop proc EmplDetails
